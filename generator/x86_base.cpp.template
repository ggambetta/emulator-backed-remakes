// Automatically generated. DO NOT EDIT!
#include "x86_base.h"

#include <cassert>
#include <iostream>

using namespace std;

static const char* BINARY2[4] = { "00", "01", "10", "11" };
static const char* BINARY3[8] = {
    "000", "001", "010", "011", "100", "101", "110", "111" };

static const char* REG16_DESC[12] = {
    "AX", "BX", "CX", "DX", "CS", "DS", "SS", "ES", "BP", "SP", "DI", "SI" };

static const char* REG8_DESC[8] = {
    "AL", "AH", "BL", "BH", "CL", "CH", "DL", "DH" };


X86Base::X86Base() {
}

X86Base::~X86Base() {
}


void X86Base::addConstArgDesc(const char* desc) {
  if (arg1_desc_ == nullptr) {
    arg1_desc_ = desc;
  } else if (arg2_desc_ == nullptr) {
    arg2_desc_ = desc;
  } else {
    assert(false);
  }
}

word X86Base::fetch16() {
  byte lo = fetch();
  byte hi = fetch();
  return lo | (hi << 8);
}

void X86Base::fetchModRM() {
  modrm_ = fetch();
}


word* X86Base::decodeRRR_w(int rrr) {
  static const int MODRM_REG_16[8] = { R16_AX, R16_CX, R16_DX, R16_BX,
                                       R16_SP, R16_BP, R16_SI, R16_DI };
  assert(rrr < 8);
  int reg = MODRM_REG_16[rrr];

  addConstArgDesc(REG16_DESC[reg]);
  return getReg16Ptr(reg);
}


byte* X86Base::decodeRRR_b(int rrr) {
  static const int MODRM_REG_8[8] = { R8_AL, R8_CL, R8_DL, R8_BL,
                                      R8_AH, R8_CH, R8_DH, R8_BH };
  assert(rrr < 8);
  int reg = MODRM_REG_8[rrr];

  addConstArgDesc(REG8_DESC[reg]);
  return getReg8Ptr(reg);
}

word* X86Base::decodeI_w() {
  immediate_ = fetch16();
  return &immediate_;
}

word* X86Base::decodeReg_w() {
  int reg = (modrm_ & 0b00111000) >> 3;
  return decodeRRR_w(reg);
}


word* X86Base::decodeS() {
  static const int MODRM_SEG[4] = { R16_ES, R16_CS, R16_SS, R16_DS };
  int sss = (modrm_ & 0b00111000) >> 3;
  assert(sss < 4);
  int seg = MODRM_SEG[sss];

  addConstArgDesc(REG16_DESC[seg]);
  return getReg16Ptr(seg);
}


word* X86Base::decodeRM_w() {
  int mod = (modrm_ & 0b11000000) >> 6;
  int rm =  (modrm_ & 0b00000111);

  if (mod == 0b11) {
    // rm is a general register.
    return decodeRRR_w(rm);
  }

  if (mod == 0b00 && rm == 0b110) {
    int offset = fetch16();
    return getMem16Ptr(segment_, offset);
  }

  cerr << "Couldn't decode ModR/M: mod = " << BINARY2[mod] << ", rm = "
       << BINARY3[rm] << endl;
  assert(false);
}


byte* X86Base::decodeReg_b() {
  int reg = (modrm_ & 0b00111000) >> 3;
  return decodeRRR_b(reg);
}


byte* X86Base::decodeRM_b() {
  assert(false);
  return nullptr;
}


void X86Base::reset() {
}


string X86Base::getOpcodeDesc() const {
  string desc;

  desc += opcode_desc_;
  desc += " ";
  if (arg1_desc_) {
    desc += arg1_desc_;
    if (arg2_desc_) {
      desc += ", ";
      desc += arg2_desc_;
    }
  }

  return desc;
}


void X86Base::step() {
  modrm_ = 0;
  barg1 = barg2 = nullptr;
  warg1 = warg2 = nullptr;
  arg1_desc_ = nullptr;
  arg2_desc_ = nullptr;
  segment_ = *getReg16Ptr(R16_DS);
  opcode_desc_ = "";
  segment_desc_ = "";

  bool is_prefix;
  do {
    is_prefix = false;
    opcode_ = fetch();

    // GENERATED CODE
  } while (is_prefix);
}